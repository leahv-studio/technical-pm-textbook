#!/bin/bash
# bk-capture-screenshot
#
# Capture a screenshot of a MicroSim using Chrome headless mode.
# Can be run from within a MicroSim directory or by specifying a path.
#
# Usage:
#   cd /path/to/microsim && bk-capture-screenshot
#   bk-capture-screenshot /path/to/microsim
#   bk-capture-screenshot /path/to/microsim 5        # 5 second delay
#   bk-capture-screenshot /path/to/microsim 3 700    # 3 second delay, 700px height
#
# Arguments:
#   $1  MicroSim directory path (default: current directory)
#   $2  Delay in seconds for JS rendering (default: 3)
#   $3  Target image height in pixels (default: 600)
#       Tip: use the iframe height from the MicroSim's index.md file.
#
# Output:
#   Creates <microsim-name>.png in the MicroSim directory.
#
# Requirements:
#   - Google Chrome or Chromium
#   - Python 3 with Pillow (PIL) for image cropping
#
# WebGL support:
#   This script uses --use-gl=angle --use-angle=swiftshader to enable
#   software-based WebGL rendering in Chrome headless mode. This is
#   required for MicroSims that use p5.js WEBGL mode (3D rendering).
#   Without these flags (e.g., with the older --disable-gpu flag),
#   WEBGL canvases render as blank white rectangles.
#
#   WEBGL MicroSims that load external fonts via loadFont() from a CDN
#   may need a longer delay (e.g., 10 seconds) to allow the font to
#   download before the screenshot is captured.
#
# Screenshot approach â€” "render tall, crop to fit":
#   Chrome headless --window-size sets the browser window dimensions, but on
#   macOS the actual viewport is smaller than specified due to internal
#   overhead (~30-50px). This causes the bottom of the page to be clipped
#   when the window height matches the content height exactly.
#
#   A fixed-pixel buffer does not work well because:
#     - Too small: bottom controls still get clipped on taller canvases
#     - Too large: excess whitespace appears below the canvas
#
#   Instead, this script:
#     1. Renders at (target height + 200px) so the full page content is
#        guaranteed to be within the viewport, with room to spare.
#     2. Uses Python PIL to crop the captured image from the top down to
#        the exact target height, removing any excess whitespace below
#        the canvas.
#
#   This produces pixel-perfect screenshots that match the iframe height
#   with no clipping and no wasted space.

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Default delay in seconds (time to wait for JavaScript to load)
DELAY_SECONDS=3

# Default window dimensions
WINDOW_WIDTH=800
WINDOW_HEIGHT=600

# Parse arguments
if [ $# -eq 0 ]; then
    # No argument provided - use current directory
    MICROSIM_DIR="$(pwd)"
elif [ $# -eq 1 ]; then
    # One argument - use it as directory
    MICROSIM_DIR="$1"
elif [ $# -eq 2 ]; then
    # Two arguments - directory and delay
    MICROSIM_DIR="$1"
    DELAY_SECONDS="$2"
else
    # Three arguments - directory, delay, and height
    MICROSIM_DIR="$1"
    DELAY_SECONDS="$2"
    WINDOW_HEIGHT="$3"
fi

# Chrome headless --window-size has viewport overhead that can clip the bottom.
# Strategy: render at a generous height, then crop the image to the exact target.
TARGET_HEIGHT=$WINDOW_HEIGHT
CAPTURE_HEIGHT=$((WINDOW_HEIGHT + 200))

# Convert delay to milliseconds for Chrome
DELAY_MS=$((DELAY_SECONDS * 1000))

# Validate directory exists
if [ ! -d "$MICROSIM_DIR" ]; then
    echo -e "${RED}Error: Directory does not exist: $MICROSIM_DIR${NC}"
    exit 1
fi

# Validate main.html exists
if [ ! -f "$MICROSIM_DIR/main.html" ]; then
    echo -e "${RED}Error: main.html not found in $MICROSIM_DIR${NC}"
    echo -e "${YELLOW}This script must be run from a MicroSim directory or provided a path to one.${NC}"
    echo ""
    echo "A MicroSim directory should contain:"
    echo "  - main.html (the simulation file)"
    echo "  - index.md (documentation)"
    echo "  - metadata.json (metadata)"
    exit 1
fi

# Extract MicroSim name from directory path
MICROSIM_NAME=$(basename "$MICROSIM_DIR")

# Construct paths
MAIN_HTML_PATH="$MICROSIM_DIR/main.html"
OUTPUT_IMAGE="$MICROSIM_DIR/${MICROSIM_NAME}.png"

# Get absolute path for file:// URL
ABSOLUTE_PATH=$(cd "$MICROSIM_DIR" && pwd)/main.html

# Chrome paths to try (in order of preference)
CHROME_PATHS=(
    "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
    "/usr/bin/google-chrome"
    "/usr/bin/chromium"
    "google-chrome"
    "chromium"
)

# Find Chrome
CHROME_BIN=""
for path in "${CHROME_PATHS[@]}"; do
    if [ -f "$path" ] || command -v "$path" &> /dev/null; then
        CHROME_BIN="$path"
        break
    fi
done

if [ -z "$CHROME_BIN" ]; then
    echo -e "${RED}Error: Chrome/Chromium not found.${NC}"
    echo "Please install Google Chrome from: https://www.google.com/chrome/"
    exit 1
fi

echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${GREEN}MicroSim Screenshot Capture${NC}"
echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo ""
echo -e "ğŸ“¸ Capturing screenshot of MicroSim: ${YELLOW}$MICROSIM_NAME${NC}"
echo -e "   Source: ${BLUE}$ABSOLUTE_PATH${NC}"
echo -e "   Output: ${BLUE}$OUTPUT_IMAGE${NC}"
echo -e "   Size:   ${YELLOW}${WINDOW_WIDTH}x${TARGET_HEIGHT}${NC}"
echo -e "   Delay:  ${YELLOW}${DELAY_SECONDS} seconds${NC} (waiting for JavaScript to load)"
echo ""

# Capture screenshot using Chrome headless mode
# Key flags:
#   --headless=new: Use new headless mode
#   --use-gl=angle --use-angle=swiftshader: Software WebGL rendering (needed for WEBGL canvases)
#   --screenshot: Capture screenshot
#   --window-size: Set viewport size
#   --hide-scrollbars: Remove scrollbars from capture
#   --disable-web-security: Allow loading external resources (CDNs)
#   --allow-file-access-from-files: Allow file:// URLs to load resources
#   --virtual-time-budget: Give JavaScript time to load and render (in milliseconds)

"$CHROME_BIN" \
    --headless=new \
    --use-gl=angle \
    --use-angle=swiftshader \
    --screenshot="$OUTPUT_IMAGE" \
    --window-size=${WINDOW_WIDTH},${CAPTURE_HEIGHT} \
    --hide-scrollbars \
    --disable-web-security \
    --allow-file-access-from-files \
    --virtual-time-budget=$DELAY_MS \
    "file://$ABSOLUTE_PATH" \
    2>&1 | grep -v "CVDisplayLink" | grep -v "SharedImageManager" || true

# Verify screenshot was created, then crop to exact target height
if [ -f "$OUTPUT_IMAGE" ]; then
    # Crop to exact target height, keeping the top portion of the image
    python3 -c "
from PIL import Image
img = Image.open('$OUTPUT_IMAGE')
if img.height > $TARGET_HEIGHT:
    img.crop((0, 0, img.width, $TARGET_HEIGHT)).save('$OUTPUT_IMAGE')
" 2>/dev/null
    SIZE=$(ls -lh "$OUTPUT_IMAGE" | awk '{print $5}')
    echo -e "${GREEN}âœ… Screenshot captured successfully!${NC}"
    echo -e "   File: ${YELLOW}$OUTPUT_IMAGE${NC} (${SIZE})"
    echo ""
    echo -e "${BLUE}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
else
    echo -e "${RED}âŒ Failed to capture screenshot${NC}"
    echo "Chrome may have encountered an error. Try running with more verbose output."
    exit 1
fi
